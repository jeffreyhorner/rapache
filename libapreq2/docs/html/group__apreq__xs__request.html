<html>
<head>
  <link rel="stylesheet" type="text/css" href="dox.css" />
  <title>libapreq2-2.05-dev: libapreq2: Apache2::Request</title> 
</head>
<body>
<div id="page-header">
<p class="menu">
   <a href="http://www.apache.org/">Apache Software Foundation</a> &gt; <a href="http://httpd.apache.org">HTTP Server Project</a> &gt;
<a href="http://httpd.apache.org/apreq/">Request Library Subproject</a></p>
<p class="apache">Apache HTTP Server Request Library</p>
<img alt="" src="feather.gif" /></div>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>Apache2::Request<br>
<small>
[<a class="el" href="group__apreq__xs.html">Perl</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
</table>


<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<li><a href="#apache2__request">Apache2::Request</a></li>
	<ul>

		<li><a href="#new">new</a></li>
		<li><a href="#instance">instance</a></li>
		<li><a href="#param">param</a></li>
		<li><a href="#parms__params">parms, params</a></li>
		<li><a href="#body">body</a></li>
		<li><a href="#upload">upload</a></li>
		<li><a href="#args_status">args_status</a></li>
		<li><a href="#body_status">body_status</a></li>
		<li><a href="#param_status">param_status</a></li>
		<li><a href="#parse">parse</a></li>
	</ul>

	<li><a href="#subclassing_apache2__request">SUBCLASSING Apache2::Request</a></li>
	<li><a href="#porting_from_1_x">PORTING from 1.X</a></li>
	<li><a href="#see_also">SEE ALSO</a></li>
	<li><a href="#copyright">COPYRIGHT</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>Apache2::Request - Methods for dealing with client request data</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
    use Apache2::Request;
    $req = Apache2::Request-&gt;new($r);
    @foo = $req-&gt;param(&quot;foo&quot;);
    $bar = $req-&gt;args(&quot;bar&quot;);</pre>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>The Apache2::Request module provides methods for parsing GET and POST parameters
encoded with either <em>application/x-www-form-urlencoded</em> or <em>multipart/form-data</em>.
Although Apache2::Request provides a few new APIs for accessing the parsed data,
it remains largely backwards-compatible with the original 1.X API.  See the
<a href="#porting_from_1_x">PORTING from 1.X</a> section below for a list of known issues.</p>
<p>This manpage documents the Apache2::Request package.</p>
<p>
</p>
<hr />
<h1><a name="apache2__request">Apache2::Request</a></h1>
<p>The interface is designed to mimic the CGI.pm routines for parsing
query parameters. The main differences are</p>
<ul>
<li><strong><a name="item_as"><code>Apache2::Request::new</code> takes an environment-specific
        object <code>$r</code> as (second) argument.  Newer versions of CGI.pm also accept
        this syntax within modperl.</a></strong><br />
</li>
<li><strong><a name="item_the_query_parameters_are_stored_in_apr_3a_3atable_">The query parameters are stored in APR::Table derived objects, and
        are therefore retrieved from the table by using case-insensitive keys.</a></strong><br />
</li>
<li><strong><a name="item_the_query_string_is_always_parsed_immediately_2c_e">The query string is always parsed immediately, even for POST requests.</a></strong><br />
</li>
</ul>
<p>
</p>
<h2><a name="new">new</a></h2>
<pre>
    Apache2::Request-&gt;new($r, %args)</pre>
<p>Creates a new Apache2::Request object.</p>
<pre>
    my $req = Apache2::Request-&gt;new($r, POST_MAX =&gt; &quot;1M&quot;);</pre>
<p>With mod_perl2, the environment object $r must be an Apache2::RequestRec
object.  In that case, all methods from Apache2::RequestRec are inherited.
In the (default) CGI environment, $r must be an APR::Pool object.</p>
<p>The following args are optional:</p>
<ul>
<li><strong><a name="item_post_max_2c_max_body"><code>POST_MAX</code>, <code>MAX_BODY</code></a></strong><br />
</li>
Limit the size of POST data (in bytes).
<p></p>
<li><strong><a name="item_disable_uploads"><code>DISABLE_UPLOADS</code></a></strong><br />
</li>
Disable file uploads.
<p></p>
<li><strong><a name="item_temp_dir"><code>TEMP_DIR</code></a></strong><br />
</li>
Sets the directory where upload files are spooled.  On a *nix-like
that supports <em>link(2)</em>, the TEMP_DIR should be located on the same
file system as the final destination file:
<pre>
 use Apache2::Upload;
 my $req = Apache2::Request-&gt;new($r, TEMP_DIR =&gt; &quot;/home/httpd/tmp&quot;);
 my $upload = $req-&gt;upload('file');
 $upload-&gt;link(&quot;/home/user/myfile&quot;);</pre>
<p>For more details on <code>link</code>, see <a href="/Apache2/Upload.html">the Apache2::Upload manpage</a>.</p>
<p></p>
<li><strong><a name="item_hook_data"><code>HOOK_DATA</code></a></strong><br />
</li>
Extra configuration info passed as the fourth argument 
to an upload hook.  See the description for the next item, 
<a href="#item_upload_hook"><code>UPLOAD_HOOK</code></a>.
<p></p>
<li><strong><a name="item_upload_hook"><code>UPLOAD_HOOK</code></a></strong><br />
</li>
Sets up a callback to run whenever file upload data is read. This
can be used to provide an upload progress meter during file uploads.
Apache will automatically continue writing the original data to
$upload-&gt;fh after the hook exits.
<pre>
  my $transparent_hook = sub {
    my ($upload, $data, $data_len, $hook_data) = @_;
    warn &quot;$hook_data: got $data_len bytes for &quot; . $upload-&gt;name;
  };</pre>
<pre>
  my $req = Apache2::Request-&gt;new($r, 
                                  HOOK_DATA =&gt; &quot;Note&quot;,
                                  UPLOAD_HOOK =&gt; $transparent_hook,
                                 );</pre>
<p></p></ul>
<p>
</p>
<h2><a name="instance">instance</a></h2>
<pre>
    Apache2::Request-&gt;instance($r)</pre>
<p>The default (and only) behavior of <em>Apache2::Request</em> is to intelligently
cache <strong>POST</strong> data for the duration of the request.  Thus there is no longer
the need for a separate <a href="#item_instance"><code>instance()</code></a> method as existed in <em>Apache2::Request</em>
for Apache 1.3 - all <strong>POST</strong> data is always available from each and every 
<em>Apache2::Request</em> object created during the request's lifetime.</p>
<p>However an <a href="#item_instance"><code>instance()</code></a> method is aliased to <code>new()</code> in this release
to ease the pain of porting from 1.X to 2.X.</p>
<p>
</p>
<h2><a name="param">param</a></h2>
<pre>
    $req-&gt;param()
    $req-&gt;param($name)</pre>
<p>Get the request parameters (using case-insensitive keys) by
mimicing the OO interface of <code>CGI::param</code>.</p>
<pre>
    # similar to CGI.pm</pre>
<pre>
    my $foo_value   = $req-&gt;param('foo');
    my @foo_values  = $req-&gt;param('foo');
    my @param_names = $req-&gt;param;</pre>
<pre>
    # the following differ slightly from CGI.pm</pre>
<pre>
    # returns ref to APR::Request::Param::Table object representing 
    # all (args + body) params
    my $table = $req-&gt;param;
    @table_keys = keys %$table;</pre>
<p>In list context, or when invoked with no arguments as 
<code>$req-&gt;param()</code>, <code>param</code> induces libapreq2 to read 
and parse all remaining data in the request body.
However, <code>scalar $req-&gt;param(&quot;foo&quot;)</code> is lazy: libapreq2 
will only read and parse more data if</p>
<pre>
    1) no &quot;foo&quot; param appears in the query string arguments, AND
    2) no &quot;foo&quot; param appears in the previously parsed POST data.</pre>
<p>In this circumstance libapreq2 will read and parse additional
blocks of the incoming request body until either</p>
<pre>
    1) it has found the the &quot;foo&quot; param, or 
    2) parsing is completed.</pre>
<p>Observe that <code>scalar $req-&gt;param(&quot;foo&quot;)</code> will not raise
an exception if it can locate ``foo'' in the existing body or
args tables, even if the query-string parser or the body parser
has failed.  In all other circumstances <code>param</code> will throw an
Apache2::Request::Error object into $@ should either parser fail.</p>
<pre>
    $req-&gt;args_status(1); # set error state for query-string parser 
    ok $req-&gt;param_status == 1;</pre>
<pre>
    $foo = $req-&gt;param(&quot;foo&quot;);
    ok $foo == 1;
    eval { @foo = $req-&gt;param(&quot;foo&quot;) };
    ok $@-&gt;isa(&quot;Apache2::Request::Error&quot;);
    undef $@;
    eval { my $not_found = $req-&gt;param(&quot;non-existent-param&quot;) };
    ok $@-&gt;isa(&quot;Apache2::Request::Error&quot;);</pre>
<pre>
    $req-&gt;args_status(0); # reset query-string parser state to &quot;success&quot;</pre>
<p>Note: modifications to the <code>scalar $req-&gt;param()</code> table only
affect the returned table object (the underlying C apr_table_t is 
<em>generated</em> from the parse data by apreq_params()).  Modifications 
do not affect the actual request data, and will not be seen by other 
libapreq2 applications.</p>
<p>
</p>
<h2><a name="parms__params">parms, params</a></h2>
<p>The functionality of these functions is assumed by <code>param</code>,
so they are no longer necessary.  Aliases to <code>param</code> are
provided in this release for backwards compatibility,
however they are deprecated and may be removed from a future 
release.</p>
<p>
</p>
<h2><a name="body">body</a></h2>
<pre>
    $req-&gt;body()
    $req-&gt;body($name)</pre>
<p>Returns an <em>APR::Request::Param::Table</em> object containing the POST data
parameters of the <em>Apache2::Request</em> object.</p>
<pre>
    my $body = $req-&gt;body;</pre>
<p>An optional name parameter can be passed to return the POST data
parameter associated with the given name:</p>
<pre>
    my $foo_body = $req-&gt;body(&quot;foo&quot;);</pre>
<p>More generally, <code>body()</code> follows the same pattern as <code>param()</code>
with respect to its return values and argument list.  The main difference
is that modifications to the <code>scalar $req-&gt;body()</code> table affect
the underlying apr_table_t attribute in apreq_request_t, so their impact 
will be noticed by all libapreq2 applications during this request.</p>
<p>
</p>
<h2><a name="upload">upload</a></h2>
<pre>
    $req-&gt;upload()
    $req-&gt;upload($name)</pre>
<p>Requires <code>Apache2::Upload</code>.  With no arguments, this method
returns an <em>APR::Request::Param::Table</em> object in scalar context, 
or the names of all <em>Apache2::Upload</em> objects in list context.</p>
<p>An optional name parameter can be passed to return the <em>Apache2::Upload</em>
object associated with the given name:</p>
<pre>
    my $upload = $req-&gt;upload($name);</pre>
<p>More generally, <code>upload()</code> follows the same pattern as <code>param()</code>
with respect to its return values and argument list.  The main difference
is that its returned values are Apache2::Upload object refs, not 
simple scalars.</p>
<p>Note: modifications to the <code>scalar $req-&gt;upload()</code> table only
affect the returned table object (the underlying C apr_table_t is 
<em>generated</em> by apreq_uploads()).  They do not affect the actual request 
data, and will not be seen by other libapreq2 applications.</p>
<p>
</p>
<h2><a name="args_status">args_status</a></h2>
<pre>
    $req-&gt;args_status()
    $req-&gt;args_status($set)</pre>
<p>Get/set the <em>APR</em> status code of the query-string parser.
APR_SUCCESS on success, error otherwise.</p>
<p>
</p>
<h2><a name="body_status">body_status</a></h2>
<pre>
    $req-&gt;body_status()
    $req-&gt;body_status($set)</pre>
<p>Get/set the current <em>APR</em> status code of the parsed POST data.
APR_SUCCESS when parser has completed, APR_INCOMPLETE if parser
has more data to parse, APR_EINIT if no post data has been parsed,
error otherwise.</p>
<p>
</p>
<h2><a name="param_status">param_status</a></h2>
<pre>
    $req-&gt;param_status()</pre>
<p>In scalar context, this returns <code>args_status</code> if there was
an error during the query-string parse, otherwise this returns
<code>body_status</code>, ie</p>
<pre>
    $req-&gt;args_status || $req-&gt;body_status</pre>
<p>In list context <code>param_status</code> returns the list 
<code>(args_status, body_status)</code>.</p>
<p>
</p>
<h2><a name="parse">parse</a></h2>
<pre>
    $req-&gt;parse()</pre>
<p>Forces the request to be parsed immediately.  In void context,
this will throw an APR::Request::Error should the either the
query-string or body parser fail. In all other contexts it will
return the two parsers' combined <em>APR</em> status code</p>
<pre>
    $req-&gt;body_status || $req-&gt;args_status</pre>
<p>However <code>parse</code> should be avoided in most normal situations.  For example,
in a mod_perl content handler it is more efficient to write</p>
<pre>
    sub handler {
        my $r = shift;
        my $req = Apache2::Request-&gt;new($r);
        $r-&gt;discard_request_body;   # efficiently parses the request body
        my $parser_status = $req-&gt;body_status;</pre>
<pre>
        #...
    }</pre>
<p>Calling <code>$r-&gt;discard_request_body</code> outside the content handler
is generally a mistake, so use <code>$req-&gt;parse</code> there, but 
<strong>only as a last resort</strong>.  The Apache2::Request API is <strong>designed</strong> 
around a lazy-parsing scheme, so calling <code>parse</code> should not
affect the behavior of any other methods.</p>
<p>
</p>
<hr />
<h1><a name="subclassing_apache2__request">SUBCLASSING Apache2::Request</a></h1>
<p>If the instances of your subclass are hash references then you can actually
inherit from Apache2::Request as long as the Apache2::Request object is stored in
an attribute called ``r'' or ``_r''. (The Apache2::Request class effectively does the
delegation for you automagically, as long as it knows where to find the
Apache2::Request object to delegate to.)  For example:</p>
<pre>
        package MySubClass;
        use Apache2::Request;
        our @ISA = qw(Apache2::Request);
        sub new {
                my($class, @args) = @_;
                return bless { r =&gt; Apache2::Request-&gt;new(@args) }, $class;
        }</pre>
<p>
</p>
<hr />
<h1><a name="porting_from_1_x">PORTING from 1.X</a></h1>
<p>This is the complete list of changes to existing methods 
from Apache2::Request 1.X.  These issues need to be 
addressed when porting 1.X apps to the new 2.X API.</p>
<ul>
<li><strong><a name="item_apache2_3a_3aupload_is_now_a_separate_module_2e_ap">Apache2::Upload is now a separate module.  Applications
        requiring the upload API must <code>use Apache2::Upload</code> in 2.X.
        This is easily addressed by preloading the modules during 
        server startup.</a></strong><br />
</li>
<li><strong><a name="item_args">You must use the <code>Apache2::Request::Table</code> API via 
        <code>scalar $req-&gt;args</code> or <code>scalar $req-&gt;body</code> 
        to assign new parameters to the request.  You may 
        no longer use the two-argument method calls; e.g.</a></strong><br />
</li>
<pre>
          $req-&gt;param(&quot;foo&quot; =&gt; &quot;bar&quot;); # NO: usage error in 2.X
          $req-&gt;args-&gt;{foo} = &quot;bar&quot;;   # OK: assign to args table
          $req-&gt;body-&gt;add(foo =&gt; &quot;bar&quot;);  # OK: add to body table</pre>
<pre>
          $req-&gt;param-&gt;add(foo =&gt; &quot;bar&quot;); # NO: this is an expensive noop,
                                          # because the param table is
                                          # generated by overlaying $req-&gt;args
                                          # and $req-&gt;body.</pre>
<pre>
          my $params = $req-&gt;param;
          $params-&gt;set(foo =&gt; &quot;bar&quot;); # OK: sets &quot;foo&quot; entry in $params, which
                                      # is a local (args + body) table. Neither
                                      # $req-&gt;args, $req-&gt;body, nor future calls
                                      # to $req-&gt;param, are affected by mods to
                                      # $params.</pre>
<li><strong><a name="item_instance"><code>instance()</code> is now identical to <code>new()</code>, and is now deprecated.  It 
        may be removed from a future 2.X release.</a></strong><br />
</li>
<li><strong><a name="item_parms"><code>param</code> includes the functionality of <code>parms()</code> and <code>params()</code>, so
        they are now deprecated and may be removed from a future 2.X release.</a></strong><br />
</li>
</ul>
<p>
</p>
<hr />
<h1><a name="see_also">SEE ALSO</a></h1>
<p><a href="/APR/Request/Param.html">the APR::Request::Param manpage</a>, <a href="/APR/Request/Error.html">the APR::Request::Error manpage</a>, <a href="/Apache2/Upload.html">the Apache2::Upload manpage</a>,
<a href="/Apache2/Cookie.html">the Apache2::Cookie manpage</a>, APR::Table(3).</p>
<p>
</p>
<hr />
<h1><a name="copyright">COPYRIGHT</a></h1>
<pre>
  Copyright 2003-2005  The Apache Software Foundation</pre>
<pre>
  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at</pre>
<pre>
      <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></pre>
<pre>
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.</pre>

 <div id="footer">
<p class="apache">
Copyright &copy; 2003-2005 <a href="http://www.apache.org">The Apache Software Foundation</a>.<br/>
See <a href="apreq_license.html">LICENSE</a>.</p>
<p class="menu">
<span style="color:#aaa">page generated by <a href="http://www.doxygen.org/"><code>doxygen</code></a>
version 1.4.2 on 4 May 2005</span>
</p>
</div>
</body>
</html>
